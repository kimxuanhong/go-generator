package logrus

import (
	"os"

	"github.com/sirupsen/logrus"
)

// Config holds Logrus configuration
type Config struct {
	Level      string `json:"level"`       // debug, info, warn, error
	Format     string `json:"format"`      // json, text
	Output     string `json:"output"`      // stdout, stderr, file path
	ReportCaller bool `json:"reportCaller"` // Include caller information
}

// Logger wraps the Logrus logger
type Logger struct {
	*logrus.Logger
}

// New creates a new Logrus logger
func New(cfg Config) *Logger {
	logger := logrus.New()

	// Set level
	level := parseLevel(cfg.Level)
	logger.SetLevel(level)

	// Set formatter
	if cfg.Format == "json" {
		logger.SetFormatter(&logrus.JSONFormatter{
			CallerPrettyfier: nil,
		})
	} else {
		logger.SetFormatter(&logrus.TextFormatter{
			FullTimestamp: true,
		})
	}

	// Set output
	if cfg.Output != "" && cfg.Output != "stdout" && cfg.Output != "stderr" {
		file, err := os.OpenFile(cfg.Output, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
		if err == nil {
			logger.SetOutput(file)
		} else {
			logger.SetOutput(os.Stdout)
		}
	} else if cfg.Output == "stderr" {
		logger.SetOutput(os.Stderr)
	} else {
		logger.SetOutput(os.Stdout)
	}

	// Set report caller
	logger.SetReportCaller(cfg.ReportCaller)

	return &Logger{Logger: logger}
}

// parseLevel parses log level string to logrus.Level
func parseLevel(level string) logrus.Level {
	switch level {
	case "debug":
		return logrus.DebugLevel
	case "info":
		return logrus.InfoLevel
	case "warn":
		return logrus.WarnLevel
	case "error":
		return logrus.ErrorLevel
	case "fatal":
		return logrus.FatalLevel
	case "panic":
		return logrus.PanicLevel
	default:
		return logrus.InfoLevel
	}
}

// Close closes the logger (no-op for logrus, but included for consistency)
func (l *Logger) Close() error {
	return nil
}

