package deps

import (
	"fmt"
	"strings"
	{{- if index .Includes "redis"}}
	"{{.ModuleName}}/internal/infrastructure/redis"
	{{- end}}
	{{- if index .Includes "postgres"}}
	"{{.ModuleName}}/internal/infrastructure/postgres"
	{{- end}}
	{{- if index .Includes "mysql"}}
	"{{.ModuleName}}/internal/infrastructure/mysql"
	{{- end}}
	{{- if index .Includes "logrus"}}
	"{{.ModuleName}}/internal/infrastructure/logrus"
	{{- end}}
	{{- if index .Includes "resty"}}
	"{{.ModuleName}}/internal/infrastructure/resty"
	{{- end}}
	{{- if index .Includes "cron"}}
	"{{.ModuleName}}/internal/infrastructure/cron"
	{{- end}}
	{{- if index .Includes "rabbitmq"}}
	"{{.ModuleName}}/internal/infrastructure/rabbitmq"
	{{- end}}
	{{- if index .Includes "kafka"}}
	kafkainfra "{{.ModuleName}}/internal/infrastructure/kafka"
	{{- end}}
	{{- if index .Includes "activemq"}}
	activemqinfra "{{.ModuleName}}/internal/infrastructure/activemq"
	{{- end}}
	{{- if index .Includes "gorm"}}
	gormcfg "{{.ModuleName}}/internal/infrastructure/gorm"
	{{- end}}
	{{- if index .Includes "mapstructure"}}
	mapstructureinfra "{{.ModuleName}}/internal/infrastructure/mapstructure"
	{{- end}}
	{{- if index .Includes "validator"}}
	validatorinfra "{{.ModuleName}}/internal/infrastructure/validator"
	{{- end}}
	{{- if index .Includes "opentelemetry"}}
	otelinfra "{{.ModuleName}}/internal/infrastructure/opentelemetry"
	{{- end}}

	mapstructure "github.com/mitchellh/mapstructure"
	"github.com/spf13/viper"
)

// Framework config structs
{{- if eq .Framework "fiber"}}
// FiberConfig holds Fiber server configuration
type FiberConfig struct {
	Host string `json:"host" mapstructure:"host"`
	Port int    `json:"port" mapstructure:"port"`
}

// GetAddr returns the address string for Fiber server
func (c *FiberConfig) GetAddr() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}
{{- else if eq .Framework "gin"}}
// GinConfig holds Gin server configuration
type GinConfig struct {
	Host string `json:"host" mapstructure:"host"`
	Port int    `json:"port" mapstructure:"port"`
	Mode string `json:"mode" mapstructure:"mode"`
}

// GetAddr returns the address string for Gin server
func (c *GinConfig) GetAddr() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}
{{- else if eq .Framework "echo"}}
// EchoConfig holds Echo server configuration
type EchoConfig struct {
	Host  string `json:"host" mapstructure:"host"`
	Port  int    `json:"port" mapstructure:"port"`
	Debug bool   `json:"debug" mapstructure:"debug"`
}

// GetAddr returns the address string for Echo server
func (c *EchoConfig) GetAddr() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}
{{- end}}

// Config holds the application configuration
type Config struct {
	{{- if eq .Framework "fiber"}}
	Fiber *FiberConfig `json:"fiber,omitempty" mapstructure:"fiber"`
	{{- else if eq .Framework "gin"}}
	Gin *GinConfig `json:"gin,omitempty" mapstructure:"gin"`
	{{- else if eq .Framework "echo"}}
	Echo *EchoConfig `json:"echo,omitempty" mapstructure:"echo"`
	{{- end}}
	{{- if index .Includes "redis"}}
	Redis *redis.Config `json:"redis,omitempty" mapstructure:"redis"`
	{{- end}}
	{{- if index .Includes "postgres"}}
	Postgres *postgres.Config `json:"postgres,omitempty" mapstructure:"postgres"`
	{{- end}}
	{{- if index .Includes "mysql"}}
	MySQL *mysql.Config `json:"mysql,omitempty" mapstructure:"mysql"`
	{{- end}}
	{{- if index .Includes "logrus"}}
	Logrus *logrus.Config `json:"logrus,omitempty" mapstructure:"logrus"`
	{{- end}}
	{{- if index .Includes "resty"}}
	Resty *resty.Config `json:"resty,omitempty" mapstructure:"resty"`
	{{- end}}
	{{- if index .Includes "cron"}}
	Cron *cron.Config `json:"cron,omitempty" mapstructure:"cron"`
	{{- end}}
	{{- if index .Includes "rabbitmq"}}
	RabbitMQ *rabbitmq.Config `json:"rabbitmq,omitempty" mapstructure:"rabbitmq"`
	{{- end}}
	{{- if index .Includes "kafka"}}
	Kafka *kafkainfra.Config `json:"kafka,omitempty" mapstructure:"kafka"`
	{{- end}}
	{{- if index .Includes "activemq"}}
	ActiveMQ *activemqinfra.Config `json:"activemq,omitempty" mapstructure:"activemq"`
	{{- end}}
	{{- if index .Includes "gorm"}}
	Gorm *gormcfg.Config `json:"gorm,omitempty" mapstructure:"gorm"`
	{{- end}}
	{{- if index .Includes "mapstructure"}}
	Mapstructure *mapstructureinfra.Config `json:"mapstructure,omitempty" mapstructure:"mapstructure"`
	{{- end}}
	{{- if index .Includes "validator"}}
	Validator *validatorinfra.Config `json:"validator,omitempty" mapstructure:"validator"`
	{{- end}}
	{{- if index .Includes "opentelemetry"}}
	Opentelemetry *otelinfra.Config `json:"opentelemetry,omitempty" mapstructure:"opentelemetry"`
	{{- end}}
}

// LoadConfig loads configuration from a JSON file and binds environment variables.
// Environment variables can override config values; use ALL_CAPS_WITH_UNDERSCORES for naming.
// Example: ECHO_HOST, ECHO_PORT, REDIS_ADDR, POSTGRES_DSN, etc.
func LoadConfig(path string) (*Config, error) {
	v := viper.New()

	// Set config file
	v.SetConfigFile(path)
	v.SetConfigType("json")

	// Read config file
	if err := v.ReadInConfig(); err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	// Enable environment variable overrides. Nested keys like redis.addr become REDIS_ADDR.
	v.SetEnvPrefix("") // or set a prefix like your app name if needed
	v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
	v.AutomaticEnv()

	if err := bindEnvs(v, v.AllSettings(), ""); err != nil {
		return nil, fmt.Errorf("failed to bind env vars: %w", err)
	}

	// Unmarshal into Config struct
	var cfg Config
	if err := v.Unmarshal(&cfg, viper.DecodeHook(
		mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
		),
	)); err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}

	return &cfg, nil
}

// bindEnvs walks the config tree and binds environment variables for each key.
func bindEnvs(v *viper.Viper, settings map[string]interface{}, prefix string) error {
	for key, value := range settings {
		fullKey := key
		if prefix != "" {
			fullKey = prefix + "." + key
		}

		switch typed := value.(type) {
		case map[string]interface{}:
			if err := bindEnvs(v, typed, fullKey); err != nil {
				return err
			}
		case []interface{}:
			// Skip explicit binding for slices; they can still be overridden by flat env vars if desired.
			continue
		default:
			if err := v.BindEnv(fullKey); err != nil {
				return err
			}
		}
	}
	return nil
}
