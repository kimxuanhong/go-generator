package deps

import (
	"fmt"
	"strings"
	{{- range $name, $m := .Meta }}
    {{- if index $.Includes $name }}
    {{- range $imp := $m.Imports }}
    {{$imp}}
    {{- end }}
    {{- end }}
    {{- end }}

    mapstructure "github.com/mitchellh/mapstructure"
	"github.com/spf13/viper"
)

// Framework config structs
{{- if eq .Framework "fiber"}}
// FiberConfig holds Fiber server configuration
type FiberConfig struct {
	Host string `json:"host" mapstructure:"host"`
	Port int    `json:"port" mapstructure:"port"`
}

// GetAddr returns the address string for Fiber server
func (c *FiberConfig) GetAddr() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}

// Validate validates FiberConfig values
func (c *FiberConfig) Validate() error {
	if c.Host == "" {
		return fmt.Errorf("fiber host is required")
	}
	if c.Port <= 0 || c.Port > 65535 {
		return fmt.Errorf("fiber port must be between 1 and 65535, got %d", c.Port)
	}
	return nil
}

// SetDefaults sets default values for FiberConfig
func (c *FiberConfig) SetDefaults() {
	if c.Host == "" {
		c.Host = "0.0.0.0"
	}
	if c.Port == 0 {
		c.Port = 8080
	}
}
{{- else if eq .Framework "gin"}}
// GinConfig holds Gin server configuration
type GinConfig struct {
	Host string `json:"host" mapstructure:"host"`
	Port int    `json:"port" mapstructure:"port"`
	Mode string `json:"mode" mapstructure:"mode"`
}

// GetAddr returns the address string for Gin server
func (c *GinConfig) GetAddr() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}

// Validate validates GinConfig values
func (c *GinConfig) Validate() error {
	if c.Host == "" {
		return fmt.Errorf("gin host is required")
	}
	if c.Port <= 0 || c.Port > 65535 {
		return fmt.Errorf("gin port must be between 1 and 65535, got %d", c.Port)
	}
	if c.Mode != "" && c.Mode != "debug" && c.Mode != "release" && c.Mode != "test" {
		return fmt.Errorf("gin mode must be one of: debug, release, test, got %s", c.Mode)
	}
	return nil
}

// SetDefaults sets default values for GinConfig
func (c *GinConfig) SetDefaults() {
	if c.Host == "" {
		c.Host = "0.0.0.0"
	}
	if c.Port == 0 {
		c.Port = 8080
	}
	if c.Mode == "" {
		c.Mode = "debug"
	}
}
{{- else if eq .Framework "echo"}}
// EchoConfig holds Echo server configuration
type EchoConfig struct {
	Host  string `json:"host" mapstructure:"host"`
	Port  int    `json:"port" mapstructure:"port"`
	Debug bool   `json:"debug" mapstructure:"debug"`
}

// GetAddr returns the address string for Echo server
func (c *EchoConfig) GetAddr() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}

// Validate validates EchoConfig values
func (c *EchoConfig) Validate() error {
	if c.Host == "" {
		return fmt.Errorf("echo host is required")
	}
	if c.Port <= 0 || c.Port > 65535 {
		return fmt.Errorf("echo port must be between 1 and 65535, got %d", c.Port)
	}
	return nil
}

// SetDefaults sets default values for EchoConfig
func (c *EchoConfig) SetDefaults() {
	if c.Host == "" {
		c.Host = "0.0.0.0"
	}
	if c.Port == 0 {
		c.Port = 8080
	}
}
{{- end}}

// LogConfig holds logging configuration
type LogConfig struct {
	Level string `json:"level" mapstructure:"level"` // debug, info, warn, error, fatal, panic
}

// Config holds the application configuration
type Config struct {
	Log *LogConfig `json:"log,omitempty" mapstructure:"log"`

	{{- if eq .Framework "fiber"}}
	Fiber *FiberConfig `json:"fiber,omitempty" mapstructure:"fiber"`
	{{- else if eq .Framework "gin"}}
	Gin *GinConfig `json:"gin,omitempty" mapstructure:"gin"`
	{{- else if eq .Framework "echo"}}
	Echo *EchoConfig `json:"echo,omitempty" mapstructure:"echo"`
	{{- end}}

	{{- range $name, $m := .Meta }}
	{{- if index $.Includes $name }}
	{{$m.ConfigField}}
	{{- end }}
	{{- end }}
}

// LoadConfig loads configuration from a JSON file and binds environment variables.
// Environment variables can override config values; use ALL_CAPS_WITH_UNDERSCORES for naming.
// Example: ECHO_HOST, ECHO_PORT, REDIS_ADDR, POSTGRES_DSN, etc.
func LoadConfig(path string) (*Config, error) {
	v := viper.New()

	// Set config file
	v.SetConfigFile(path)
	v.SetConfigType("json")

	// Read config file
	if err := v.ReadInConfig(); err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	// Enable environment variable overrides. Nested keys like redis.addr become REDIS_ADDR.
	v.SetEnvPrefix("") // or set a prefix like your app name if needed
	v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
	v.AutomaticEnv()

	if err := bindEnvs(v, v.AllSettings(), ""); err != nil {
		return nil, fmt.Errorf("failed to bind env vars: %w", err)
	}

	// Unmarshal into Config struct
	var cfg Config
	if err := v.Unmarshal(&cfg, viper.DecodeHook(
		mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
		),
	)); err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}

	// Set defaults before validation
	cfg.SetDefaults()

	// Validate config
	if err := cfg.Validate(); err != nil {
		return nil, fmt.Errorf("invalid config: %w", err)
	}

	return &cfg, nil
}

// bindEnvs walks the config tree and binds environment variables for each key.
func bindEnvs(v *viper.Viper, settings map[string]interface{}, prefix string) error {
	for key, value := range settings {
		fullKey := key
		if prefix != "" {
			fullKey = prefix + "." + key
		}

		switch typed := value.(type) {
		case map[string]interface{}:
			if err := bindEnvs(v, typed, fullKey); err != nil {
				return err
			}
		case []interface{}:
			// Skip explicit binding for slices; they can still be overridden by flat env vars if desired.
			continue
		default:
			if err := v.BindEnv(fullKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// Validate validates the configuration
func (c *Config) Validate() error {
	{{- if eq .Framework "fiber"}}
	if c.Fiber != nil {
		if err := c.Fiber.Validate(); err != nil {
			return fmt.Errorf("fiber config: %w", err)
		}
	} else {
		return fmt.Errorf("fiber config is required")
	}
	{{- else if eq .Framework "gin"}}
	if c.Gin != nil {
		if err := c.Gin.Validate(); err != nil {
			return fmt.Errorf("gin config: %w", err)
		}
	} else {
		return fmt.Errorf("gin config is required")
	}
	{{- else if eq .Framework "echo"}}
	if c.Echo != nil {
		if err := c.Echo.Validate(); err != nil {
			return fmt.Errorf("echo config: %w", err)
		}
	} else {
		return fmt.Errorf("echo config is required")
	}
	{{- end}}

	// Validate library configs
	{{- range $name, $m := .Meta }}
	{{- if index $.Includes $name }}
	// Note: Library-specific validation would be added here if needed
	// For now, we rely on the library's own validation during initialization
	{{- end }}
	{{- end }}

	return nil
}

// SetDefaults sets default values for the configuration
func (c *Config) SetDefaults() {
	{{- if eq .Framework "fiber"}}
	if c.Fiber != nil {
		c.Fiber.SetDefaults()
	}
	{{- else if eq .Framework "gin"}}
	if c.Gin != nil {
		c.Gin.SetDefaults()
	}
	{{- else if eq .Framework "echo"}}
	if c.Echo != nil {
		c.Echo.SetDefaults()
	}
	{{- end }}

	// Set defaults for library configs if needed
	// Library-specific defaults would be set here
}
