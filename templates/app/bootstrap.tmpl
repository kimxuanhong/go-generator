package app

import (
    {{- if index .Includes "cron"}}
    "{{.ModuleName}}/internal/adapter/job"
    {{- end}}
    {{- if or (index .Includes "rabbitmq") (index .Includes "kafka") (index .Includes "activemq")}}
    "{{.ModuleName}}/internal/adapter/consumer"
    {{- end}}

    "{{.ModuleName}}/internal/adapter/handler"
    "{{.ModuleName}}/internal/domain"
    "{{.ModuleName}}/internal/infrastructure/repository"
    "{{.ModuleName}}/internal/usecase"
    "{{.ModuleName}}/internal/deps"
)

// SetupDependencies initializes repositories, usecases, handlers, consumers, and optional jobs.
// BootstrapResult groups the initialized components returned by SetupDependencies.
type BootstrapResult struct {
    UserRepo    domain.UserRepository
    CacheRepo   domain.CacheRepository
    UserUsecase *usecase.UserUsecase
    UserHandler *handler.UserHandler
    {{- if index .Includes "cron"}}
    ExampleJob  *job.ExampleJob
    {{- end}}
    {{- if index .Includes "rabbitmq"}}
    UserRabbitConsumer *consumer.UserRabbitMQConsumer
    {{- end}}
    {{- if index .Includes "kafka"}}
    UserKafkaConsumer *consumer.UserKafkaConsumer
    {{- end}}
    {{- if index .Includes "activemq"}}
    UserActiveMQConsumer *consumer.UserActiveMQConsumer
    {{- end}}
}

func SetupDependencies(d *deps.Deps) (*BootstrapResult, error) {
    {{- if index .Includes "opentelemetry"}}
    // Get tracer for distributed tracing
    tracer := d.Tracer.Tracer("{{.ProjectName}}")
    {{- end}}
    {{- if index .Includes "validator"}}
    // Get validator for request validation
    validator := d.Validator
    {{- end}}

    // Initialize repositories
    var userRepo domain.UserRepository
    var cacheRepo domain.CacheRepository

    {{- if or (index .Includes "postgres") (index .Includes "mysql")}}
    // Pass the unified DB field (d.DB) to repository constructor
    userRepo = repository.NewUserRepository(d.DB, {{- if index .Includes "opentelemetry"}}tracer, {{- end}}d.Log)
    {{- else}}
    userRepo = repository.NewUserRepository({{- if index .Includes "opentelemetry"}}tracer, {{- end}}d.Log)
    {{- end}}

    {{- if index .Includes "redis"}}
    cacheRepo = repository.NewCacheRepository(d.Redis, d.Log)
    {{- else}}
    cacheRepo = repository.NewCacheRepository(d.Log)
    {{- end}}

    // Initialize usecase and handler
    userUsecase := usecase.NewUserUsecase(userRepo, cacheRepo{{- if index .Includes "opentelemetry"}}, tracer{{- end}}, d.Log)
    userHandler := handler.NewUserHandler(userUsecase{{- if index .Includes "opentelemetry"}}, tracer{{- end}}{{- if index .Includes "validator"}}, validator{{- end}}, d.Log)

    // Optional job initialization (only if cron is enabled)
    {{- if index .Includes "cron"}}
    exampleJob := job.NewExampleJob(d, d.Log)
    {{- end}}

    // Initialize message queue consumers (Input Adapters - Domain specific)
    // All config (queues, topics, brokers) is hardcoded per domain or loaded from deps
    {{- if index .Includes "rabbitmq"}}
    userRabbitConsumer := consumer.NewUserRabbitMQConsumer(d, userUsecase)
    {{- end}}
    {{- if index .Includes "kafka"}}
    userKafkaConsumer := consumer.NewUserKafkaConsumer(d, userUsecase)
    {{- end}}
    {{- if index .Includes "activemq"}}
    userActiveMQConsumer := consumer.NewUserActiveMQConsumer(d, userUsecase)
    {{- end}}

    // Pack results into a single struct to simplify the generated API.
    result := &BootstrapResult{
        UserRepo:    userRepo,
        CacheRepo:   cacheRepo,
        UserUsecase: userUsecase,
        UserHandler: userHandler,
        {{- if index .Includes "cron"}}
        ExampleJob:  exampleJob,
        {{- end}}
        {{- if index .Includes "rabbitmq"}}
        UserRabbitConsumer: userRabbitConsumer,
        {{- end}}
        {{- if index .Includes "kafka"}}
        UserKafkaConsumer: userKafkaConsumer,
        {{- end}}
        {{- if index .Includes "activemq"}}
        UserActiveMQConsumer: userActiveMQConsumer,
        {{- end}}
    }

    return result, nil
}
