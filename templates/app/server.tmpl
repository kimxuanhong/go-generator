package app

import (
	"context"
	"fmt"
	"log"
	{{- if or (eq .Framework "gin") (eq .Framework "echo")}}
	"net/http"
	{{- end}}

	{{- if eq .Framework "fiber"}}
	fiberSwagger "github.com/gofiber/swagger"
	"github.com/gofiber/fiber/v2"
	{{- else if eq .Framework "gin"}}
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"github.com/gin-gonic/gin"
	{{- else if eq .Framework "echo"}}
	echoSwagger "github.com/swaggo/echo-swagger"
	"github.com/labstack/echo/v4"
	{{- end}}
	"time"
	
	_ "{{.ModuleName}}/docs"
	"{{.ModuleName}}/internal/deps"
	"{{.ModuleName}}/internal/middleware"
)

// Server holds the application server
type Server struct {
	{{- if eq .Framework "fiber"}}
	app *fiber.App
	{{- else if eq .Framework "gin"}}
	router *gin.Engine
	srv    *http.Server
	{{- else if eq .Framework "echo"}}
	echo *echo.Echo
	{{- end}}
}

// NewServer creates a new server instance
func NewServer(d *deps.Deps) (*Server, error) {
	// Initialize components via bootstrap (returns a grouped result)
	res, err := SetupDependencies(d)
	if err != nil {
		return nil, fmt.Errorf("failed to setup dependencies: %w", err)
	}

	// Register cron job (if any) â€” present in BootstrapResult when cron is enabled
	{{- if index .Includes "cron"}}
	if res.ExampleJob != nil && d.Cron != nil {
		_, err := d.Cron.AddJob("0 */5 * * * *", res.ExampleJob)
		if err != nil {
			return nil, fmt.Errorf("failed to register cron job: %w", err)
		}
		d.Log.Info("Cron job registered: example-job (runs every 5 minutes)")
	}
	{{- end}}

	// Start message queue consumers (Input Adapters - Domain specific)
	{{- if index .Includes "rabbitmq"}}
	if res.UserRabbitConsumer != nil && d.RabbitMQ != nil {
		go res.UserRabbitConsumer.Run()
		d.Log.Info("User RabbitMQ consumer started")
	}
	{{- end}}
	{{- if index .Includes "kafka"}}
	if res.UserKafkaConsumer != nil && d.Kafka != nil {
		go res.UserKafkaConsumer.Run()
		d.Log.Info("User Kafka consumer started")
	}
	{{- end}}
	{{- if index .Includes "activemq"}}
	if res.UserActiveMQConsumer != nil && d.ActiveMQ != nil {
		go res.UserActiveMQConsumer.Run()
		d.Log.Info("User ActiveMQ consumer started")
	}
	{{- end}}

	{{- if eq .Framework "fiber"}}
	app := fiber.New()
	
	// Apply middleware in order: tracing -> logging -> rate limit
	app.Use(middleware.TracingMiddleware())
	app.Use(middleware.LoggingMiddleware(d.Log))
	rateLimiter := middleware.NewRateLimiter(100, time.Minute, d.Log)
	app.Use(rateLimiter.Middleware())
	
	app.Get("/swagger/*", fiberSwagger.HandlerDefault)
	srv := &Server{app: app}

    {{- if eq .IncludeExample true}}
	// Register routes via centralized routes file
	RegisterRoutes(srv, res.UserHandler)
    {{- end}}

	return srv, nil
	{{- else if eq .Framework "gin"}}
	// Create router without default middleware (we'll add our own)
	router := gin.New()
	
	// Recovery middleware (Gin's built-in)
	router.Use(gin.Recovery())
	
	// Apply custom middleware in order: tracing -> logging -> rate limit
	router.Use(middleware.TracingMiddleware())
	router.Use(middleware.LoggingMiddleware(d.Log))
	rateLimiter := middleware.NewRateLimiter(100, time.Minute, d.Log)
	router.Use(rateLimiter.Middleware())
	
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	srv := &Server{router: router}

    {{- if eq .IncludeExample true}}
	// Register routes via centralized routes file
	RegisterRoutes(srv, res.UserHandler)
    {{- end}}

	return srv, nil
	{{- else if eq .Framework "echo"}}
	e := echo.New()
	
	// Apply middleware in order: tracing -> logging -> rate limit
	e.Use(middleware.TracingMiddleware())
	e.Use(middleware.LoggingMiddleware(d.Log))
	rateLimiter := middleware.NewRateLimiter(100, time.Minute, d.Log)
	e.Use(rateLimiter.Middleware())
	
	e.GET("/swagger/*", echoSwagger.WrapHandler)
	srv := &Server{echo: e}

    {{- if eq .IncludeExample true}}
	// Register routes via centralized routes file
	RegisterRoutes(srv, res.UserHandler)
    {{- end}}

	return srv, nil
	{{- end}}
}

// Start starts the server
func (s *Server) Start(cfg *deps.Config) error {
	{{- if eq .Framework "fiber"}}
	if cfg.Fiber == nil {
		return fmt.Errorf("fiber config is required")
	}
	addr := cfg.Fiber.GetAddr()
	log.Printf("Starting Fiber server on %s", addr)
	if err := s.app.Listen(addr); err != nil {
		return fmt.Errorf("failed to start fiber server: %w", err)
	}
	return nil
	{{- else if eq .Framework "gin"}}
	if cfg.Gin == nil {
		return fmt.Errorf("gin config is required")
	}
	if cfg.Gin.Mode != "" {
		gin.SetMode(cfg.Gin.Mode)
	}
	addr := cfg.Gin.GetAddr()
	log.Printf("Starting Gin server on %s", addr)
	s.srv = &http.Server{
		Addr:    addr,
		Handler: s.router,
	}
	if err := s.srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("failed to start gin server: %w", err)
	}
	return nil
	{{- else if eq .Framework "echo"}}
	if cfg.Echo == nil {
		return fmt.Errorf("echo config is required")
	}
	s.echo.Debug = cfg.Echo.Debug
	addr := cfg.Echo.GetAddr()
	log.Printf("Starting Echo server on %s", addr)
	if err := s.echo.Start(addr); err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("failed to start echo server: %w", err)
	}
	return nil
	{{- end}}
}

// Shutdown gracefully shuts down the server
func (s *Server) Shutdown(ctx context.Context) error {
	{{- if eq .Framework "fiber"}}
	log.Println("Shutting down Fiber server...")
	return s.app.ShutdownWithContext(ctx)
	{{- else if eq .Framework "gin"}}
	log.Println("Shutting down Gin server...")
	if s.srv == nil {
		return nil
	}
	return s.srv.Shutdown(ctx)
	{{- else if eq .Framework "echo"}}
	log.Println("Shutting down Echo server...")
	return s.echo.Shutdown(ctx)
	{{- end}}
}

